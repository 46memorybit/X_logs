<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Tweet Log Timeline</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  body { font-family: sans-serif; }
  .group { margin-bottom: 12px; }
  .files { margin-left: 20px; }
  .filter { margin-bottom: 16px; }
</style>
</head>
<body>

<h2>ツイート時系列（1時間単位）</h2>

<div class="filter">
  期間：
  <select id="rangeSelect">
    <option value="1d" selected>1日</option>
    <option value="7d">1週間</option>
    <option value="30d">1か月</option>
    <option value="custom">カスタム</option>
  </select>

  <span id="customRange" style="display:none">
    <input type="date" id="startDate">
    〜
    <input type="date" id="endDate">
  </span>

  <button onclick="updateChart()">反映</button>
</div>

<div id="controls"></div>

<canvas id="chart" height="120"></canvas>

<script>
/* =============================
   データ定義
   ============================= */
const DATA_STRUCTURE = {
  "櫻坂46": {
    folder: "tweet/logs/櫻坂46メンバー名/",
    files: ["#小島凪紗.csv", "#藤吉夏鈴.csv"]
  },
  "日向坂46": {
    folder: "tweet/logs/日向坂46メンバー名/",
    files: ["#金村美玖.csv"]
  }
};

const HOURS = [...Array(24)].map((_, i) => `${i}~${i+1}`);
let chart;

/* =============================
   期間計算
   ============================= */
function getDateRange() {
  const today = new Date();
  const end = new Date(today);
  const start = new Date(today);
  const type = rangeSelect.value;

  if (type === "1d") {
    // 今日のみ
  } else if (type === "7d") {
    start.setDate(start.getDate() - 6);
  } else if (type === "30d") {
    start.setMonth(start.getMonth() - 1);
  } else {
    return {
      start: startDate.value,
      end: endDate.value
    };
  }

  return {
    start: start.toISOString().slice(0,10),
    end: end.toISOString().slice(0,10)
  };
}

/* =============================
   CSV 読み込み（時系列）
   ============================= */
async function loadCSV(path, start, end) {
  const text = await fetch(path).then(r => r.text());
  const lines = text.trim().split("\n").slice(1);

  const map = new Map();

  lines.forEach(line => {
    const cols = line.split(",");
    const date = cols[0];

    if (date < start || date > end) return;

    for (let i = 1; i <= 24; i++) {
      const key = `${date} ${HOURS[i-1]}`;
      map.set(key, (map.get(key) || 0) + Number(cols[i] || 0));
    }
  });

  return map;
}

/* =============================
   チェックボックス生成
   ============================= */
function buildControls() {
  const root = document.getElementById("controls");

  for (const groupName in DATA_STRUCTURE) {
    const g = DATA_STRUCTURE[groupName];

    const div = document.createElement("div");
    div.className = "group";

    const gCheck = document.createElement("input");
    gCheck.type = "checkbox";
    gCheck.checked = true;

    const gLabel = document.createElement("label");
    gLabel.append(gCheck, " ", groupName);

    const filesDiv = document.createElement("div");
    filesDiv.className = "files";

    g.files.forEach(file => {
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = true;
      cb.dataset.path = g.folder + file;
      cb.addEventListener("change", updateChart);

      const label = document.createElement("label");
      label.append(cb, " ", file);

      filesDiv.append(label, document.createElement("br"));
    });

    gCheck.addEventListener("change", () => {
      filesDiv.querySelectorAll("input").forEach(c => c.checked = gCheck.checked);
      updateChart();
    });

    div.append(gLabel, filesDiv);
    root.appendChild(div);
  }
}

/* =============================
   グラフ更新
   ============================= */
async function updateChart() {
  const { start, end } = getDateRange();
  const checks = document.querySelectorAll(".files input:checked");

  const merged = new Map();
  const datasets = [];

  for (const cb of checks) {
    const map = await loadCSV(cb.dataset.path, start, end);
    map.forEach((v, k) => {
      if (!merged.has(k)) merged.set(k, {});
      merged.get(k)[cb.dataset.path] = v;
    });
  }

  const labels = [...merged.keys()].sort();

  checks.forEach(cb => {
    datasets.push({
      label: cb.dataset.path.split("/").pop(),
      data: labels.map(l => merged.get(l)?.[cb.dataset.path] || 0),
      tension: 0.2
    });
  });

  if (chart) chart.destroy();

  chart = new Chart(chartCanvas, {
    type: "line",
    data: { labels, datasets },
    options: {
      responsive: true,
      interaction: { mode: "nearest", intersect: false },
      scales: {
        x: { ticks: { maxRotation: 90, minRotation: 90 } },
        y: { beginAtZero: true }
      }
    }
  });
}

/* =============================
   UI 制御
   ============================= */
rangeSelect.onchange = () => {
  customRange.style.display =
    rangeSelect.value === "custom" ? "inline" : "none";
};

buildControls();
updateChart();
</script>

</body>
</html>
